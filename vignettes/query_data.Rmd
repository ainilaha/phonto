---
title: "Query Data"
output: html_document
date: "Updated on : `r date()`"
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Setup 
Install the package for the first time.
`devtools::install_github("ccb-hms/phonto")`

```{r setup,warning=FALSE,message=FALSE}
library(phonto)
library(DT)
library(nhanesA)


sqlHost <- "localhost"
sqlUserName <- "sa"
sqlPassword <- "yourStrong(!)Password"
sqlDefaultDb <- "NhanesLandingZone"

```


## Step 1: search tables

It can be search by certain variable.

### 1) The function of search table names only by veriable has been replicated
```{r search_tables,warning=FALSE,message=FALSE}
# nameonly <- nhanesSearchVarName('BPXPULS')
# nameonly

# replicate function
nameonly1 <- searchTablesByVar('BPXPULS')
nameonly1
```

### 2) We need the meta data in the databse to replicate the details if we need them.
```{r varsearch_tables,warning=FALSE,message=FALSE}
# details <- nhanesSearchVarName('BPXPULS', includerdc=TRUE, ystart=2001, ystop=2008, nchar=20,namesonly=F)
# datatable(details)
# But we can do something like this now:
searchTableByName("BPX",ystart=2001, ystop=2008)
```




### 3) Joint query
Replicated the name only version and need meta data in database to replicate the details
```{r search_tables1,warning=FALSE,message=FALSE}
cols = c("RIDAGEYR","RIAGENDR","BMXBMI","DMDEDUC2")
data = jointQuery(c('BodyMeasures','DemographicVariablesAndSampleWeights'),cols)
DT::datatable(data)
```

### 3) Union Query

```{r search_union,warning=FALSE,message=FALSE}
tablnames = searchTableByName('BPX[_]')
tablnames
blood_df <- unionQuery(tablnames$TableName,cols =c("BPXDI1","BPXDI2","BPXSY1","BPXSY2"))
DT::datatable(blood_df)
```


### 3) query by variables

We need to ensure all the variables can be found across the same table group; otherwise, the function will throw an error.

```{r search_unionvar,warning=FALSE,message=FALSE}
searchTablesByVar("URXDMA")
phy_urine = c("URXDAZ","URXDMA","URXEQU", "URXETD","URXETL","URXGNS")

# another new function that allow users query data by a group variables
phy_urine_df = queryByVars(phy_urine)
DT::datatable(phy_urine_df)
```





## Step 2: check tables

#### 1) A quick way to do it is to show the table names' details, and we can find the table named "P_BPXO" and "BPXO_J" are different from the rest of the tables that present blood pressures.
```{r check_tables,warning=FALSE,message=FALSE}
tb_detail <- nhanesSearchTableNames('BPX', includerdc=TRUE, nchar=42, details=TRUE)
datatable(tb_detail)
```
#### 2) We can also check tables by showing the variables and descriptions in the tables.
For example,
```{r check_tables2,warning=FALSE,message=FALSE}
var_detail <- variableDescr("BPX_D")
datatable(var_detail)
```

# To impalement the rest of functions: 
# We need the docker database to add a table that mapping short names(eg. BPX_C) to the long descriptive name.

## Step 3: check tables: 


### 1) Given the information from the above two steps, we can query data by specifying tables and columns.

```{r query,warning=FALSE,message=FALSE}
tables <- c("BPX_D","BPX_E","BPX","BPX_C")
cols <- c("BPXDI1","BPXDI2","BPXSY1","BPXSY2")
# bpx_data <- queryData(tables,cols)
# datatable(bpx_data)

```


### Check the data availability over the years
In the following matrix, 0 means the tables have no data in that year, and 1 means they have data in corresponding years.

```{r years,warning=FALSE,message=FALSE}

# mtx <- check_data()
# DT::datatable(
#   mtx
# ) |> DT::formatStyle(colnames(mtx),
#                  backgroundColor = styleInterval(c(0, 1), c('gray', 'red',"white")),
#                  fontWeight = 'bold')

```



